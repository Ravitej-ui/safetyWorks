/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.8.1.0 (NJsonSchema v10.2.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
import { CopyrightAppContext } from './copyright-app.context';
import { AppService } from '../app.service';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class AdminsClient extends CopyrightAppContext {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AppService) configuration: AppService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * @return Success
     */
    getAddress(): Observable<string> {
        let url_ = this.baseUrl + "/api/Admins/GetAddress";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddress(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetAddress(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param fromDate (optional)
     * @param toDate (optional)
     * @return Success
     */
    getTransactions(fromDate: Date | null | undefined, toDate: Date | null | undefined): Observable<TransactionLog[]> {
        let url_ = this.baseUrl + "/api/Admins/GetTransactions?";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactions(<any>response_);
                } catch (e) {
                    return <Observable<TransactionLog[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransactionLog[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactions(response: HttpResponseBase): Observable<TransactionLog[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TransactionLog.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionLog[]>(<any>null);
    }

    /**
     * @param fromDate (optional)
     * @param toDate (optional)
     * @return Success
     */
    getBillings(fromDate: Date | null | undefined, toDate: Date | null | undefined): Observable<Billing[]> {
        let url_ = this.baseUrl + "/api/Admins/GetBillings?";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBillings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBillings(<any>response_);
                } catch (e) {
                    return <Observable<Billing[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Billing[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBillings(response: HttpResponseBase): Observable<Billing[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Billing.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Billing[]>(<any>null);
    }

    /**
     * @return Success
     */
    getUsers(): Observable<AppUser[]> {
        let url_ = this.baseUrl + "/api/Admins/GetUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<AppUser[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppUser[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<AppUser[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppUser.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppUser[]>(<any>null);
    }

    /**
     * @return Success
     */
    getUser(id: string): Observable<AppUser> {
        let url_ = this.baseUrl + "/api/Admins/GetUser/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUser(<any>response_);
                } catch (e) {
                    return <Observable<AppUser>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppUser>><any>_observableThrow(response_);
        }));
    }

    protected processGetUser(response: HttpResponseBase): Observable<AppUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppUser>(<any>null);
    }

    /**
     * @return Success
     */
    toggleDisable(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Admins/ToggleDisable/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processToggleDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleDisable(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processToggleDisable(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class AppUsersClient extends CopyrightAppContext {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AppService) configuration: AppService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * @return Success
     */
    getCurrentUser(): Observable<AppUser> {
        let url_ = this.baseUrl + "/api/AppUsers/GetCurrentUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCurrentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUser(<any>response_);
                } catch (e) {
                    return <Observable<AppUser>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppUser>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentUser(response: HttpResponseBase): Observable<AppUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppUser>(<any>null);
    }

    /**
     * @return Success
     */
    getBalance(): Observable<number> {
        let url_ = this.baseUrl + "/api/AppUsers/GetBalance";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBalance(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetBalance(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param appUser (optional)
     * @return Success
     */
    updateProfile(appUser: AppUser | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AppUsers/UpdateProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(appUser);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getTransactions(): Observable<TransactionLog[]> {
        let url_ = this.baseUrl + "/api/AppUsers/GetTransactions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactions(<any>response_);
                } catch (e) {
                    return <Observable<TransactionLog[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransactionLog[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactions(response: HttpResponseBase): Observable<TransactionLog[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TransactionLog.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionLog[]>(<any>null);
    }

    /**
     * @return Success
     */
    getReferalTransactions(): Observable<ReferalTransaction[]> {
        let url_ = this.baseUrl + "/api/AppUsers/GetReferalTransactions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetReferalTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferalTransactions(<any>response_);
                } catch (e) {
                    return <Observable<ReferalTransaction[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferalTransaction[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferalTransactions(response: HttpResponseBase): Observable<ReferalTransaction[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReferalTransaction.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferalTransaction[]>(<any>null);
    }

    /**
     * @return Success
     */
    getReferals(): Observable<ReferalModel[]> {
        let url_ = this.baseUrl + "/api/AppUsers/GetReferals";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetReferals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReferals(<any>response_);
                } catch (e) {
                    return <Observable<ReferalModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReferalModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetReferals(response: HttpResponseBase): Observable<ReferalModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReferalModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReferalModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getDashboardData(): Observable<DashboardModel[]> {
        let url_ = this.baseUrl + "/api/AppUsers/GetDashboardData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetDashboardData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardData(<any>response_);
                } catch (e) {
                    return <Observable<DashboardModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DashboardModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardData(response: HttpResponseBase): Observable<DashboardModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DashboardModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashboardModel[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class AuthClient extends CopyrightAppContext {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AppService) configuration: AppService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * @param appUser (optional)
     * @return Success
     */
    register(appUser: AppUser | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(appUser);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param sign (optional)
     * @return Success
     */
    signIN(sign: SignIN | null | undefined): Observable<AuthData> {
        let url_ = this.baseUrl + "/api/Auth/SignIN";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sign);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processSignIN(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignIN(<any>response_);
                } catch (e) {
                    return <Observable<AuthData>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthData>><any>_observableThrow(response_);
        }));
    }

    protected processSignIN(response: HttpResponseBase): Observable<AuthData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthData>(<any>null);
    }

    /**
     * @param email (optional)
     * @return Success
     */
    forgotPassword(email: string | null | undefined): Observable<ChangePasswordResponse> {
        let url_ = this.baseUrl + "/api/Auth/ForgotPassword?";
        if (email !== undefined && email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(<any>response_);
                } catch (e) {
                    return <Observable<ChangePasswordResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChangePasswordResponse>><any>_observableThrow(response_);
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<ChangePasswordResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChangePasswordResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChangePasswordResponse>(<any>null);
    }

    /**
     * @return Success
     */
    checkResetPassword(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Auth/CheckResetPassword/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCheckResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param resetPasswordModel (optional)
     * @return Success
     */
    resetPassword(resetPasswordModel: ResetPasswordModel | null | undefined): Observable<ChangePasswordResponse> {
        let url_ = this.baseUrl + "/api/Auth/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resetPasswordModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ChangePasswordResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChangePasswordResponse>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ChangePasswordResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChangePasswordResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChangePasswordResponse>(<any>null);
    }

    /**
     * @param model (optional)
     * @return Success
     */
    changePassword(model: ChangePasswordModel | null | undefined): Observable<ChangePasswordResponse> {
        let url_ = this.baseUrl + "/api/Auth/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<ChangePasswordResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChangePasswordResponse>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<ChangePasswordResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChangePasswordResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChangePasswordResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CopyRightClient extends CopyrightAppContext {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AppService) configuration: AppService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * @return Success
     */
    getRegistrations(): Observable<Registration[]> {
        let url_ = this.baseUrl + "/api/CopyRight/GetRegistrations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetRegistrations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegistrations(<any>response_);
                } catch (e) {
                    return <Observable<Registration[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Registration[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRegistrations(response: HttpResponseBase): Observable<Registration[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Registration.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Registration[]>(<any>null);
    }

    /**
     * @return Success
     */
    getVerifications(): Observable<VerificationDModel[]> {
        let url_ = this.baseUrl + "/api/CopyRight/GetVerifications";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetVerifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVerifications(<any>response_);
                } catch (e) {
                    return <Observable<VerificationDModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<VerificationDModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetVerifications(response: HttpResponseBase): Observable<VerificationDModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VerificationDModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VerificationDModel[]>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getPdfReportData(id: string | null | undefined): Observable<RegistrationPDF> {
        let url_ = this.baseUrl + "/api/CopyRight/GetPdfReportData?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPdfReportData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPdfReportData(<any>response_);
                } catch (e) {
                    return <Observable<RegistrationPDF>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegistrationPDF>><any>_observableThrow(response_);
        }));
    }

    protected processGetPdfReportData(response: HttpResponseBase): Observable<RegistrationPDF> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegistrationPDF.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegistrationPDF>(<any>null);
    }

    /**
     * @param file (optional)
     * @param notes (optional)
     * @param classificationID (optional)
     * @return Success
     */
    register(file: FileParameter | null | undefined, notes: string | null | undefined, classificationID: string | null | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/api/CopyRight/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");
        if (notes !== null && notes !== undefined)
            content_.append("Notes", notes.toString());
        if (classificationID !== null && classificationID !== undefined)
            content_.append("ClassificationID", classificationID.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * @return Success
     */
    registerMultiple(): Observable<Response> {
        let url_ = this.baseUrl + "/api/CopyRight/RegisterMultiple";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRegisterMultiple(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterMultiple(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterMultiple(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * @param file (optional)
     * @param hash (optional)
     * @param fileHash (optional)
     * @return Success
     */
    verify(file: FileParameter | null | undefined, hash: string | null | undefined, fileHash: string | null | undefined): Observable<VerificationDModel> {
        let url_ = this.baseUrl + "/api/CopyRight/Verify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");
        if (hash !== null && hash !== undefined)
            content_.append("Hash", hash.toString());
        if (fileHash !== null && fileHash !== undefined)
            content_.append("FileHash", fileHash.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processVerify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerify(<any>response_);
                } catch (e) {
                    return <Observable<VerificationDModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<VerificationDModel>><any>_observableThrow(response_);
        }));
    }

    protected processVerify(response: HttpResponseBase): Observable<VerificationDModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VerificationDModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VerificationDModel>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DDLClient extends CopyrightAppContext {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AppService) configuration: AppService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * @return Success
     */
    getClassifications(): Observable<Classification[]> {
        let url_ = this.baseUrl + "/api/DDL/GetClassifications";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetClassifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClassifications(<any>response_);
                } catch (e) {
                    return <Observable<Classification[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Classification[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetClassifications(response: HttpResponseBase): Observable<Classification[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Classification.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Classification[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class PaymentsClient extends CopyrightAppContext {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AppService) configuration: AppService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * @param model (optional)
     * @return Success
     */
    buyPackage(model: BillingModel | null | undefined): Observable<Billing> {
        let url_ = this.baseUrl + "/api/Payments/BuyPackage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processBuyPackage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuyPackage(<any>response_);
                } catch (e) {
                    return <Observable<Billing>><any>_observableThrow(e);
                }
            } else
                return <Observable<Billing>><any>_observableThrow(response_);
        }));
    }

    protected processBuyPackage(response: HttpResponseBase): Observable<Billing> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Billing.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Billing>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ValidationsClient extends CopyrightAppContext {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(AppService) configuration: AppService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super(configuration);
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");
    }

    /**
     * @param email (optional)
     * @return Success
     */
    isEmailTaken(email: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Validations/IsEmailTaken?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processIsEmailTaken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsEmailTaken(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsEmailTaken(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param code (optional)
     * @return Success
     */
    isReferalCodeExists(code: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Validations/IsReferalCodeExists?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processIsReferalCodeExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsReferalCodeExists(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsReferalCodeExists(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

export class TransactionLog implements ITransactionLog {
    transactionID?: string | undefined;
    userID?: string | undefined;
    tokens?: number | undefined;
    fileName?: string | undefined;
    isCredit?: boolean | undefined;
    type?: string | undefined;
    totalTokensLeft?: number | undefined;
    transactionDateTime?: Date | undefined;
    user?: AppUser | undefined;

    constructor(data?: ITransactionLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionID = _data["TransactionID"];
            this.userID = _data["UserID"];
            this.tokens = _data["Tokens"];
            this.fileName = _data["FileName"];
            this.isCredit = _data["IsCredit"];
            this.type = _data["Type"];
            this.totalTokensLeft = _data["TotalTokensLeft"];
            this.transactionDateTime = _data["TransactionDateTime"] ? new Date(_data["TransactionDateTime"].toString()) : <any>undefined;
            this.user = _data["User"] ? AppUser.fromJS(_data["User"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TransactionLog {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TransactionID"] = this.transactionID;
        data["UserID"] = this.userID;
        data["Tokens"] = this.tokens;
        data["FileName"] = this.fileName;
        data["IsCredit"] = this.isCredit;
        data["Type"] = this.type;
        data["TotalTokensLeft"] = this.totalTokensLeft;
        data["TransactionDateTime"] = this.transactionDateTime ? this.transactionDateTime.toISOString() : <any>undefined;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITransactionLog {
    transactionID?: string | undefined;
    userID?: string | undefined;
    tokens?: number | undefined;
    fileName?: string | undefined;
    isCredit?: boolean | undefined;
    type?: string | undefined;
    totalTokensLeft?: number | undefined;
    transactionDateTime?: Date | undefined;
    user?: AppUser | undefined;
}

export class AppUser implements IAppUser {
    userID?: string | undefined;
    fullName?: string | undefined;
    gender?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    profession?: string | undefined;
    password?: string | undefined;
    privateKey?: string | undefined;
    nemAddress?: string | undefined;
    tokens?: number | undefined;
    referalCode?: string | undefined;
    referrer?: string | undefined;
    referalPoints?: number | undefined;
    role?: string | undefined;
    isDisabled?: boolean | undefined;
    createdDateTime?: Date | undefined;
    lastUpdatedTime?: Date | undefined;
    referrerNavigation?: AppUser | undefined;
    billing?: Billing[] | undefined;
    inverseReferrerNavigation?: AppUser[] | undefined;
    referalTransactionReferalNavigation?: ReferalTransaction[] | undefined;
    referalTransactionUser?: ReferalTransaction[] | undefined;
    registration?: Registration[] | undefined;
    transactionLog?: TransactionLog[] | undefined;
    verification?: Verification[] | undefined;
    verificationLink?: VerificationLink[] | undefined;

    constructor(data?: IAppUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userID = _data["UserID"];
            this.fullName = _data["FullName"];
            this.gender = _data["Gender"];
            this.email = _data["Email"];
            this.phoneNumber = _data["PhoneNumber"];
            this.profession = _data["Profession"];
            this.password = _data["Password"];
            this.privateKey = _data["PrivateKey"];
            this.nemAddress = _data["NemAddress"];
            this.tokens = _data["Tokens"];
            this.referalCode = _data["ReferalCode"];
            this.referrer = _data["Referrer"];
            this.referalPoints = _data["ReferalPoints"];
            this.role = _data["Role"];
            this.isDisabled = _data["IsDisabled"];
            this.createdDateTime = _data["CreatedDateTime"] ? new Date(_data["CreatedDateTime"].toString()) : <any>undefined;
            this.lastUpdatedTime = _data["LastUpdatedTime"] ? new Date(_data["LastUpdatedTime"].toString()) : <any>undefined;
            this.referrerNavigation = _data["ReferrerNavigation"] ? AppUser.fromJS(_data["ReferrerNavigation"]) : <any>undefined;
            if (Array.isArray(_data["Billing"])) {
                this.billing = [] as any;
                for (let item of _data["Billing"])
                    this.billing!.push(Billing.fromJS(item));
            }
            if (Array.isArray(_data["InverseReferrerNavigation"])) {
                this.inverseReferrerNavigation = [] as any;
                for (let item of _data["InverseReferrerNavigation"])
                    this.inverseReferrerNavigation!.push(AppUser.fromJS(item));
            }
            if (Array.isArray(_data["ReferalTransactionReferalNavigation"])) {
                this.referalTransactionReferalNavigation = [] as any;
                for (let item of _data["ReferalTransactionReferalNavigation"])
                    this.referalTransactionReferalNavigation!.push(ReferalTransaction.fromJS(item));
            }
            if (Array.isArray(_data["ReferalTransactionUser"])) {
                this.referalTransactionUser = [] as any;
                for (let item of _data["ReferalTransactionUser"])
                    this.referalTransactionUser!.push(ReferalTransaction.fromJS(item));
            }
            if (Array.isArray(_data["Registration"])) {
                this.registration = [] as any;
                for (let item of _data["Registration"])
                    this.registration!.push(Registration.fromJS(item));
            }
            if (Array.isArray(_data["TransactionLog"])) {
                this.transactionLog = [] as any;
                for (let item of _data["TransactionLog"])
                    this.transactionLog!.push(TransactionLog.fromJS(item));
            }
            if (Array.isArray(_data["Verification"])) {
                this.verification = [] as any;
                for (let item of _data["Verification"])
                    this.verification!.push(Verification.fromJS(item));
            }
            if (Array.isArray(_data["VerificationLink"])) {
                this.verificationLink = [] as any;
                for (let item of _data["VerificationLink"])
                    this.verificationLink!.push(VerificationLink.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppUser {
        data = typeof data === 'object' ? data : {};
        let result = new AppUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserID"] = this.userID;
        data["FullName"] = this.fullName;
        data["Gender"] = this.gender;
        data["Email"] = this.email;
        data["PhoneNumber"] = this.phoneNumber;
        data["Profession"] = this.profession;
        data["Password"] = this.password;
        data["PrivateKey"] = this.privateKey;
        data["NemAddress"] = this.nemAddress;
        data["Tokens"] = this.tokens;
        data["ReferalCode"] = this.referalCode;
        data["Referrer"] = this.referrer;
        data["ReferalPoints"] = this.referalPoints;
        data["Role"] = this.role;
        data["IsDisabled"] = this.isDisabled;
        data["CreatedDateTime"] = this.createdDateTime ? this.createdDateTime.toISOString() : <any>undefined;
        data["LastUpdatedTime"] = this.lastUpdatedTime ? this.lastUpdatedTime.toISOString() : <any>undefined;
        data["ReferrerNavigation"] = this.referrerNavigation ? this.referrerNavigation.toJSON() : <any>undefined;
        if (Array.isArray(this.billing)) {
            data["Billing"] = [];
            for (let item of this.billing)
                data["Billing"].push(item.toJSON());
        }
        if (Array.isArray(this.inverseReferrerNavigation)) {
            data["InverseReferrerNavigation"] = [];
            for (let item of this.inverseReferrerNavigation)
                data["InverseReferrerNavigation"].push(item.toJSON());
        }
        if (Array.isArray(this.referalTransactionReferalNavigation)) {
            data["ReferalTransactionReferalNavigation"] = [];
            for (let item of this.referalTransactionReferalNavigation)
                data["ReferalTransactionReferalNavigation"].push(item.toJSON());
        }
        if (Array.isArray(this.referalTransactionUser)) {
            data["ReferalTransactionUser"] = [];
            for (let item of this.referalTransactionUser)
                data["ReferalTransactionUser"].push(item.toJSON());
        }
        if (Array.isArray(this.registration)) {
            data["Registration"] = [];
            for (let item of this.registration)
                data["Registration"].push(item.toJSON());
        }
        if (Array.isArray(this.transactionLog)) {
            data["TransactionLog"] = [];
            for (let item of this.transactionLog)
                data["TransactionLog"].push(item.toJSON());
        }
        if (Array.isArray(this.verification)) {
            data["Verification"] = [];
            for (let item of this.verification)
                data["Verification"].push(item.toJSON());
        }
        if (Array.isArray(this.verificationLink)) {
            data["VerificationLink"] = [];
            for (let item of this.verificationLink)
                data["VerificationLink"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAppUser {
    userID?: string | undefined;
    fullName?: string | undefined;
    gender?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    profession?: string | undefined;
    password?: string | undefined;
    privateKey?: string | undefined;
    nemAddress?: string | undefined;
    tokens?: number | undefined;
    referalCode?: string | undefined;
    referrer?: string | undefined;
    referalPoints?: number | undefined;
    role?: string | undefined;
    isDisabled?: boolean | undefined;
    createdDateTime?: Date | undefined;
    lastUpdatedTime?: Date | undefined;
    referrerNavigation?: AppUser | undefined;
    billing?: Billing[] | undefined;
    inverseReferrerNavigation?: AppUser[] | undefined;
    referalTransactionReferalNavigation?: ReferalTransaction[] | undefined;
    referalTransactionUser?: ReferalTransaction[] | undefined;
    registration?: Registration[] | undefined;
    transactionLog?: TransactionLog[] | undefined;
    verification?: Verification[] | undefined;
    verificationLink?: VerificationLink[] | undefined;
}

export class Billing implements IBilling {
    billingID?: string | undefined;
    billingNo?: string | undefined;
    userID?: string | undefined;
    tokens?: number | undefined;
    price?: number | undefined;
    name?: string | undefined;
    street?: string | undefined;
    pincode?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    status?: string | undefined;
    createdDateTime?: Date | undefined;
    user?: AppUser | undefined;
    referalTransaction?: ReferalTransaction[] | undefined;

    constructor(data?: IBilling) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.billingID = _data["BillingID"];
            this.billingNo = _data["BillingNo"];
            this.userID = _data["UserID"];
            this.tokens = _data["Tokens"];
            this.price = _data["Price"];
            this.name = _data["Name"];
            this.street = _data["Street"];
            this.pincode = _data["Pincode"];
            this.city = _data["City"];
            this.country = _data["Country"];
            this.status = _data["Status"];
            this.createdDateTime = _data["CreatedDateTime"] ? new Date(_data["CreatedDateTime"].toString()) : <any>undefined;
            this.user = _data["User"] ? AppUser.fromJS(_data["User"]) : <any>undefined;
            if (Array.isArray(_data["ReferalTransaction"])) {
                this.referalTransaction = [] as any;
                for (let item of _data["ReferalTransaction"])
                    this.referalTransaction!.push(ReferalTransaction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Billing {
        data = typeof data === 'object' ? data : {};
        let result = new Billing();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["BillingID"] = this.billingID;
        data["BillingNo"] = this.billingNo;
        data["UserID"] = this.userID;
        data["Tokens"] = this.tokens;
        data["Price"] = this.price;
        data["Name"] = this.name;
        data["Street"] = this.street;
        data["Pincode"] = this.pincode;
        data["City"] = this.city;
        data["Country"] = this.country;
        data["Status"] = this.status;
        data["CreatedDateTime"] = this.createdDateTime ? this.createdDateTime.toISOString() : <any>undefined;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.referalTransaction)) {
            data["ReferalTransaction"] = [];
            for (let item of this.referalTransaction)
                data["ReferalTransaction"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBilling {
    billingID?: string | undefined;
    billingNo?: string | undefined;
    userID?: string | undefined;
    tokens?: number | undefined;
    price?: number | undefined;
    name?: string | undefined;
    street?: string | undefined;
    pincode?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    status?: string | undefined;
    createdDateTime?: Date | undefined;
    user?: AppUser | undefined;
    referalTransaction?: ReferalTransaction[] | undefined;
}

export class ReferalTransaction implements IReferalTransaction {
    referalTransactionID?: string | undefined;
    referal?: string | undefined;
    userID?: string | undefined;
    billingID?: string | undefined;
    referalPointsEarned?: number | undefined;
    transactionTime?: Date | undefined;
    billing?: Billing | undefined;
    referalNavigation?: AppUser | undefined;
    user?: AppUser | undefined;

    constructor(data?: IReferalTransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.referalTransactionID = _data["ReferalTransactionID"];
            this.referal = _data["Referal"];
            this.userID = _data["UserID"];
            this.billingID = _data["BillingID"];
            this.referalPointsEarned = _data["ReferalPointsEarned"];
            this.transactionTime = _data["TransactionTime"] ? new Date(_data["TransactionTime"].toString()) : <any>undefined;
            this.billing = _data["Billing"] ? Billing.fromJS(_data["Billing"]) : <any>undefined;
            this.referalNavigation = _data["ReferalNavigation"] ? AppUser.fromJS(_data["ReferalNavigation"]) : <any>undefined;
            this.user = _data["User"] ? AppUser.fromJS(_data["User"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReferalTransaction {
        data = typeof data === 'object' ? data : {};
        let result = new ReferalTransaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ReferalTransactionID"] = this.referalTransactionID;
        data["Referal"] = this.referal;
        data["UserID"] = this.userID;
        data["BillingID"] = this.billingID;
        data["ReferalPointsEarned"] = this.referalPointsEarned;
        data["TransactionTime"] = this.transactionTime ? this.transactionTime.toISOString() : <any>undefined;
        data["Billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["ReferalNavigation"] = this.referalNavigation ? this.referalNavigation.toJSON() : <any>undefined;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IReferalTransaction {
    referalTransactionID?: string | undefined;
    referal?: string | undefined;
    userID?: string | undefined;
    billingID?: string | undefined;
    referalPointsEarned?: number | undefined;
    transactionTime?: Date | undefined;
    billing?: Billing | undefined;
    referalNavigation?: AppUser | undefined;
    user?: AppUser | undefined;
}

export class Registration implements IRegistration {
    registrationID?: string | undefined;
    userID?: string | undefined;
    fileName?: string | undefined;
    registrationHash?: string | undefined;
    notes?: string | undefined;
    fileHashCode?: string | undefined;
    transferHash?: string | undefined;
    status?: string | undefined;
    isPublished?: boolean | undefined;
    inQueue?: boolean | undefined;
    statusCode?: number | undefined;
    createdDateTime?: Date | undefined;
    lastUpdatedTime?: Date | undefined;
    classificationID?: string | undefined;
    classification?: Classification | undefined;
    user?: AppUser | undefined;
    verification?: Verification[] | undefined;

    constructor(data?: IRegistration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registrationID = _data["RegistrationID"];
            this.userID = _data["UserID"];
            this.fileName = _data["FileName"];
            this.registrationHash = _data["RegistrationHash"];
            this.notes = _data["Notes"];
            this.fileHashCode = _data["FileHashCode"];
            this.transferHash = _data["TransferHash"];
            this.status = _data["Status"];
            this.isPublished = _data["IsPublished"];
            this.inQueue = _data["InQueue"];
            this.statusCode = _data["StatusCode"];
            this.createdDateTime = _data["CreatedDateTime"] ? new Date(_data["CreatedDateTime"].toString()) : <any>undefined;
            this.lastUpdatedTime = _data["LastUpdatedTime"] ? new Date(_data["LastUpdatedTime"].toString()) : <any>undefined;
            this.classificationID = _data["ClassificationID"];
            this.classification = _data["Classification"] ? Classification.fromJS(_data["Classification"]) : <any>undefined;
            this.user = _data["User"] ? AppUser.fromJS(_data["User"]) : <any>undefined;
            if (Array.isArray(_data["Verification"])) {
                this.verification = [] as any;
                for (let item of _data["Verification"])
                    this.verification!.push(Verification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Registration {
        data = typeof data === 'object' ? data : {};
        let result = new Registration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RegistrationID"] = this.registrationID;
        data["UserID"] = this.userID;
        data["FileName"] = this.fileName;
        data["RegistrationHash"] = this.registrationHash;
        data["Notes"] = this.notes;
        data["FileHashCode"] = this.fileHashCode;
        data["TransferHash"] = this.transferHash;
        data["Status"] = this.status;
        data["IsPublished"] = this.isPublished;
        data["InQueue"] = this.inQueue;
        data["StatusCode"] = this.statusCode;
        data["CreatedDateTime"] = this.createdDateTime ? this.createdDateTime.toISOString() : <any>undefined;
        data["LastUpdatedTime"] = this.lastUpdatedTime ? this.lastUpdatedTime.toISOString() : <any>undefined;
        data["ClassificationID"] = this.classificationID;
        data["Classification"] = this.classification ? this.classification.toJSON() : <any>undefined;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.verification)) {
            data["Verification"] = [];
            for (let item of this.verification)
                data["Verification"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRegistration {
    registrationID?: string | undefined;
    userID?: string | undefined;
    fileName?: string | undefined;
    registrationHash?: string | undefined;
    notes?: string | undefined;
    fileHashCode?: string | undefined;
    transferHash?: string | undefined;
    status?: string | undefined;
    isPublished?: boolean | undefined;
    inQueue?: boolean | undefined;
    statusCode?: number | undefined;
    createdDateTime?: Date | undefined;
    lastUpdatedTime?: Date | undefined;
    classificationID?: string | undefined;
    classification?: Classification | undefined;
    user?: AppUser | undefined;
    verification?: Verification[] | undefined;
}

export class Verification implements IVerification {
    verificationID?: string | undefined;
    userID?: string | undefined;
    registrationID?: string | undefined;
    status?: string | undefined;
    statusCode?: number | undefined;
    createdDateTime?: Date | undefined;
    registration?: Registration | undefined;
    user?: AppUser | undefined;

    constructor(data?: IVerification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.verificationID = _data["VerificationID"];
            this.userID = _data["UserID"];
            this.registrationID = _data["RegistrationID"];
            this.status = _data["Status"];
            this.statusCode = _data["StatusCode"];
            this.createdDateTime = _data["CreatedDateTime"] ? new Date(_data["CreatedDateTime"].toString()) : <any>undefined;
            this.registration = _data["Registration"] ? Registration.fromJS(_data["Registration"]) : <any>undefined;
            this.user = _data["User"] ? AppUser.fromJS(_data["User"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Verification {
        data = typeof data === 'object' ? data : {};
        let result = new Verification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["VerificationID"] = this.verificationID;
        data["UserID"] = this.userID;
        data["RegistrationID"] = this.registrationID;
        data["Status"] = this.status;
        data["StatusCode"] = this.statusCode;
        data["CreatedDateTime"] = this.createdDateTime ? this.createdDateTime.toISOString() : <any>undefined;
        data["Registration"] = this.registration ? this.registration.toJSON() : <any>undefined;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IVerification {
    verificationID?: string | undefined;
    userID?: string | undefined;
    registrationID?: string | undefined;
    status?: string | undefined;
    statusCode?: number | undefined;
    createdDateTime?: Date | undefined;
    registration?: Registration | undefined;
    user?: AppUser | undefined;
}

export class VerificationLink implements IVerificationLink {
    resetID?: string | undefined;
    userID?: string | undefined;
    createdDate?: Date | undefined;
    expiryDate?: Date | undefined;
    user?: AppUser | undefined;

    constructor(data?: IVerificationLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resetID = _data["ResetID"];
            this.userID = _data["UserID"];
            this.createdDate = _data["CreatedDate"] ? new Date(_data["CreatedDate"].toString()) : <any>undefined;
            this.expiryDate = _data["ExpiryDate"] ? new Date(_data["ExpiryDate"].toString()) : <any>undefined;
            this.user = _data["User"] ? AppUser.fromJS(_data["User"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VerificationLink {
        data = typeof data === 'object' ? data : {};
        let result = new VerificationLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ResetID"] = this.resetID;
        data["UserID"] = this.userID;
        data["CreatedDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["ExpiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IVerificationLink {
    resetID?: string | undefined;
    userID?: string | undefined;
    createdDate?: Date | undefined;
    expiryDate?: Date | undefined;
    user?: AppUser | undefined;
}

export class Classification implements IClassification {
    classificationID?: string | undefined;
    name?: string | undefined;
    details?: string | undefined;
    registration?: Registration[] | undefined;

    constructor(data?: IClassification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classificationID = _data["ClassificationID"];
            this.name = _data["Name"];
            this.details = _data["Details"];
            if (Array.isArray(_data["Registration"])) {
                this.registration = [] as any;
                for (let item of _data["Registration"])
                    this.registration!.push(Registration.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Classification {
        data = typeof data === 'object' ? data : {};
        let result = new Classification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ClassificationID"] = this.classificationID;
        data["Name"] = this.name;
        data["Details"] = this.details;
        if (Array.isArray(this.registration)) {
            data["Registration"] = [];
            for (let item of this.registration)
                data["Registration"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClassification {
    classificationID?: string | undefined;
    name?: string | undefined;
    details?: string | undefined;
    registration?: Registration[] | undefined;
}

export class ReferalModel implements IReferalModel {
    userID?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    pointsEarned?: number | undefined;

    constructor(data?: IReferalModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userID = _data["UserID"];
            this.userName = _data["UserName"];
            this.email = _data["Email"];
            this.pointsEarned = _data["PointsEarned"];
        }
    }

    static fromJS(data: any): ReferalModel {
        data = typeof data === 'object' ? data : {};
        let result = new ReferalModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserID"] = this.userID;
        data["UserName"] = this.userName;
        data["Email"] = this.email;
        data["PointsEarned"] = this.pointsEarned;
        return data;
    }
}

export interface IReferalModel {
    userID?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    pointsEarned?: number | undefined;
}

export class DashboardModel implements IDashboardModel {
    title?: string | undefined;
    cols?: number | undefined;
    rows?: number | undefined;
    value?: number | undefined;

    constructor(data?: IDashboardModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.cols = _data["cols"];
            this.rows = _data["rows"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): DashboardModel {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["cols"] = this.cols;
        data["rows"] = this.rows;
        data["value"] = this.value;
        return data;
    }
}

export interface IDashboardModel {
    title?: string | undefined;
    cols?: number | undefined;
    rows?: number | undefined;
    value?: number | undefined;
}

export class SignIN implements ISignIN {
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: ISignIN) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["Email"];
            this.password = _data["Password"];
        }
    }

    static fromJS(data: any): SignIN {
        data = typeof data === 'object' ? data : {};
        let result = new SignIN();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Email"] = this.email;
        data["Password"] = this.password;
        return data;
    }
}

export interface ISignIN {
    email?: string | undefined;
    password?: string | undefined;
}

export class AuthData implements IAuthData {
    accessToken?: string | undefined;
    name?: string | undefined;
    nEMAddress?: string | undefined;
    role?: string | undefined;

    constructor(data?: IAuthData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["AccessToken"];
            this.name = _data["Name"];
            this.nEMAddress = _data["NEMAddress"];
            this.role = _data["Role"];
        }
    }

    static fromJS(data: any): AuthData {
        data = typeof data === 'object' ? data : {};
        let result = new AuthData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AccessToken"] = this.accessToken;
        data["Name"] = this.name;
        data["NEMAddress"] = this.nEMAddress;
        data["Role"] = this.role;
        return data;
    }
}

export interface IAuthData {
    accessToken?: string | undefined;
    name?: string | undefined;
    nEMAddress?: string | undefined;
    role?: string | undefined;
}

export class ChangePasswordResponse implements IChangePasswordResponse {
    message?: string | undefined;
    code?: number | undefined;

    constructor(data?: IChangePasswordResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["Message"];
            this.code = _data["Code"];
        }
    }

    static fromJS(data: any): ChangePasswordResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Message"] = this.message;
        data["Code"] = this.code;
        return data;
    }
}

export interface IChangePasswordResponse {
    message?: string | undefined;
    code?: number | undefined;
}

export class ResetPasswordModel implements IResetPasswordModel {
    confirmationID?: string | undefined;
    password?: string | undefined;

    constructor(data?: IResetPasswordModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.confirmationID = _data["ConfirmationID"];
            this.password = _data["Password"];
        }
    }

    static fromJS(data: any): ResetPasswordModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ConfirmationID"] = this.confirmationID;
        data["Password"] = this.password;
        return data;
    }
}

export interface IResetPasswordModel {
    confirmationID?: string | undefined;
    password?: string | undefined;
}

export class ChangePasswordModel implements IChangePasswordModel {
    currentPassword?: string | undefined;
    newPassword?: string | undefined;

    constructor(data?: IChangePasswordModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["CurrentPassword"];
            this.newPassword = _data["NewPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordModel {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CurrentPassword"] = this.currentPassword;
        data["NewPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordModel {
    currentPassword?: string | undefined;
    newPassword?: string | undefined;
}

export class VerificationDModel implements IVerificationDModel {
    verificationID?: string | undefined;
    fileName?: string | undefined;
    email?: string | undefined;
    hash?: string | undefined;
    status?: string | undefined;
    statusCode?: number | undefined;
    registrationDate?: Date | undefined;
    verificationDate?: Date | undefined;

    constructor(data?: IVerificationDModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.verificationID = _data["VerificationID"];
            this.fileName = _data["FileName"];
            this.email = _data["Email"];
            this.hash = _data["Hash"];
            this.status = _data["Status"];
            this.statusCode = _data["StatusCode"];
            this.registrationDate = _data["RegistrationDate"] ? new Date(_data["RegistrationDate"].toString()) : <any>undefined;
            this.verificationDate = _data["VerificationDate"] ? new Date(_data["VerificationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): VerificationDModel {
        data = typeof data === 'object' ? data : {};
        let result = new VerificationDModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["VerificationID"] = this.verificationID;
        data["FileName"] = this.fileName;
        data["Email"] = this.email;
        data["Hash"] = this.hash;
        data["Status"] = this.status;
        data["StatusCode"] = this.statusCode;
        data["RegistrationDate"] = this.registrationDate ? this.registrationDate.toISOString() : <any>undefined;
        data["VerificationDate"] = this.verificationDate ? this.verificationDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IVerificationDModel {
    verificationID?: string | undefined;
    fileName?: string | undefined;
    email?: string | undefined;
    hash?: string | undefined;
    status?: string | undefined;
    statusCode?: number | undefined;
    registrationDate?: Date | undefined;
    verificationDate?: Date | undefined;
}

export class RegistrationPDF implements IRegistrationPDF {
    fileName?: string | undefined;
    email?: string | undefined;
    hash?: string | undefined;
    createdDateTime?: Date | undefined;

    constructor(data?: IRegistrationPDF) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["FileName"];
            this.email = _data["Email"];
            this.hash = _data["Hash"];
            this.createdDateTime = _data["CreatedDateTime"] ? new Date(_data["CreatedDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RegistrationPDF {
        data = typeof data === 'object' ? data : {};
        let result = new RegistrationPDF();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FileName"] = this.fileName;
        data["Email"] = this.email;
        data["Hash"] = this.hash;
        data["CreatedDateTime"] = this.createdDateTime ? this.createdDateTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IRegistrationPDF {
    fileName?: string | undefined;
    email?: string | undefined;
    hash?: string | undefined;
    createdDateTime?: Date | undefined;
}

export class Response implements IResponse {
    message?: string | undefined;
    code?: number | undefined;
    tokensLeft?: number | undefined;

    constructor(data?: IResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["Message"];
            this.code = _data["Code"];
            this.tokensLeft = _data["TokensLeft"];
        }
    }

    static fromJS(data: any): Response {
        data = typeof data === 'object' ? data : {};
        let result = new Response();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Message"] = this.message;
        data["Code"] = this.code;
        data["TokensLeft"] = this.tokensLeft;
        return data;
    }
}

export interface IResponse {
    message?: string | undefined;
    code?: number | undefined;
    tokensLeft?: number | undefined;
}

export class BillingModel implements IBillingModel {
    name?: string | undefined;
    street?: string | undefined;
    pincode?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    tokens?: number | undefined;

    constructor(data?: IBillingModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.street = _data["Street"];
            this.pincode = _data["Pincode"];
            this.city = _data["City"];
            this.country = _data["Country"];
            this.tokens = _data["Tokens"];
        }
    }

    static fromJS(data: any): BillingModel {
        data = typeof data === 'object' ? data : {};
        let result = new BillingModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Street"] = this.street;
        data["Pincode"] = this.pincode;
        data["City"] = this.city;
        data["Country"] = this.country;
        data["Tokens"] = this.tokens;
        return data;
    }
}

export interface IBillingModel {
    name?: string | undefined;
    street?: string | undefined;
    pincode?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    tokens?: number | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
